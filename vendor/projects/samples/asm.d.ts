export declare const Fill = "// Runs an infinite loop that listens to the keyboard input. \n// When a key is pressed (any key), the program blackens the screen,\n// i.e. writes \"black\" in every pixel. When no key is pressed, \n// the screen should be cleared.\n\n// initialize variables\n(START)\t\t\t// while (true)\n\t@SCREEN\n\tD=A\n\t@i\n\tM=D\t\t// i = SCREEN\n\n(LOOP)\t\t\t// while (i < screen - 1)\n\t@i\n\tD=M\n\t@24575\t\t// screen - 1\n\tD=A-D\n\t@START\n\tD;JLT\t\t// i < screen - 1 (negative check)\n\t@KBD\n\tD=M\n\t@BLACKEN\t// if (kbd != 0)\n\tD;JNE\n\n// Clear the screen (write \"white\" in every pixel)\n\t@i\n\tD=M\n\tA=D\n\tM=0\t\t// write \"white\"\n\t@CONTINUE\n\t0;JMP\n\n(BLACKEN)\n\t@i\n\tD=M\n\tA=D\n\tM=-1\t\t// write \"black\"\n\n(CONTINUE)\n\t@i\n\tM=M+1\t\t// i++\n\t@LOOP\n\t0;JMP\n        ";
export declare const FillAlt1 = "// This file is part of www.nand2tetris.org\n// and the book \"The Elements of Computing Systems\"\n// by Nisan and Schocken, MIT Press.\n// File name: projects/04/Fill.asm\n\n// This version uses two similar loops to fill the screen either with\n// black or white.  Each loop always starts filling the screen from\n// the top.  The press or release of a key flips between the two loops.\n//\n// The advantage of this program over the single loop program is that\n// it is much more responsive to changes in key state.  One can watch\n// it working even when the CPU simulator is running with animation.\n\n(FILL_WHITE)\n        @SCREEN\n        D=A\n        @pScreen\n        M=D             // pScreen = pointer to SCREEN\n\n(WHITE_LOOP)\n        @KBD            // if key down fill screen with black\n        D=M\n        @FILL_BLACK\n        D;JNE\n        @pScreen        // Memory[pScreen] = black (0)\n        A=M\n        M=0\n\n        @pScreen        // pScreen = pScreen + 1\n        MD=M+1\n\n        @24576          // SCREEN + size of screen\n        D=D-A\n        @WHITE_LOOP\n        D;JLT           // loop if pScreen still within screen\n\n        @FILL_WHITE     // restart at beginning of screen\n        0;JMP\n\n\n(FILL_BLACK)\n        @SCREEN\n        D=A\n        @pScreen\n        M=D             // pScreen = pointer to SCREEN\n\n(BLACK_LOOP)\n        @KBD            // if key down fill screen with white\n        D=M\n        @FILL_WHITE\n        D;JEQ\n        @pScreen        // Memory[pScreen] = white (-1)\n        A=M\n        M=-1\n\n        @pScreen        // pScreen = pScreen + 1\n        MD=M+1\n\n        @24576          // SCREEN + size of screen\n        D=D-A\n        @BLACK_LOOP\n        D;JLT           // loop if pScreen still within screen\n\n        @FILL_BLACK     // restart at beginning of screen\n        0;JMP\n";
export declare const FillAlt2 = "// This version uses a single loop.  When a key is down, the loop\n// writes black and increments the screen pointer.  When no key is\n// down, it decrements the screen pointer and writes white.\n//\n// The advantages of this program over the original single loop program\n// and the double loop program are that it is much more responsive to\n// changes in key state and that it does not leave partially written\n// black bands temporarily visible on the screen.  (And it looks cool!)\n\n        @SCREEN\n        D=A\n        @pScreen\n        M=D             // pScreen = pointer to SCREEN\n\n(LOOP)\n        @KBD            // if key down fill screen with black\n        D=M\n        @FILL_BLACK\n        D;JNE\n                        // Roll back the darkness\n        @pScreen\n        D=M\n        @SCREEN         // if pScreen <= SCREEN there is nothing to do\n        D=D-A\n        @LOOP\n        D;JLE\n\n        @pScreen\n        AM=M-1          // A = pScreen = pScreen - 1\n        M=0             // Memory[pScreen] = white (0)\n\n        @LOOP\n        0;JMP\n\n(FILL_BLACK)            // Let darkness descend\n        @pScreen\n        D=M\n        @24576          // if pScreen >= SCREEN + size of screen,\n        D=D-A           // there is nothing to do\n        @LOOP\n        D;JGE\n\n        @pScreen        // Memory[pScreen] = black (-1)\n        A=M\n        M=-1\n\n        @pScreen        // pScreen = pScreen + 1\n        M=M+1\n\n        @LOOP\n        0;JMP\n";
export declare const Mult = "// Multiplies R0 and R1 and stores the result in R2.\n// (R0, R1, R2 refer to RAM[0], RAM[1], and RAM[2], respectively.)\n// The algorithm is based on repetitive addition.\n\n// Initialize the variables\n        @sum\n        M=0\n        @R0\n        D=M\n        @i\n        M=D\n(LOOP)\n        @i\n        MD=M-1  // decrement the counter\n        @FINISH\n        D;JLT\n        @R1\n        D=M\n        @sum\n        M=D+M   // tally the sum\n        @LOOP\n        0;JMP\n(FINISH)\n        @sum\n        D=M\n        @R2\n        M=D\n(END)\n        @END\n        0;JMP";
export declare const MultAlt1 = "// Multiplies R0 and R1 and stores the result in R2.\n// (R0, R1, R2 refer to RAM[0], RAM[1], and RAM[2], respectively.)\n// The algorithm is based on repetitive addition.\n\n        @R2     // Zero the partial product\n        M=0\n\n(LOOP)\n        @R1\n        MD=M-1  // Decrement and test the multiplier\n        @HALT\n        D;JLT\n\n        @R0     // Add the multiplicand to the partial product\n        D=M\n        @R2\n        M=D+M\n        @LOOP\n        0;JMP\n\n(HALT)\n        @HALT\n        0;JMP";
export declare const MultCmp = "|  RAM[2]  |\n|       0  |\n|       0  |\n|       0  |\n|       3  |\n|       8  |\n|      42  |";
export declare const MultTst = "output-list RAM[2]%D2.6.2;\n\nset RAM[0] 0,\nset RAM[1] 0;\nrepeat 20 {\n  ticktock;\n}\noutput;\n\nset PC 0,\nset RAM[0] 1,\nset RAM[1] 0;\nrepeat 50 {\n  ticktock;\n}\noutput;\n\nset PC 0,\nset RAM[0] 0,\nset RAM[1] 2;\nrepeat 80 {\n  ticktock;\n}\noutput;\n\nset PC 0,\nset RAM[0] 3,\nset RAM[1] 1;\nrepeat 120 {\n  ticktock;\n}\noutput;\n\nset PC 0,\nset RAM[0] 2,\nset RAM[1] 4;\nrepeat 150 {\n  ticktock;\n}\noutput;\n\nset PC 0,\nset RAM[0] 6,\nset RAM[1] 7;\nrepeat 210 {\n  ticktock;\n}\noutput;";
